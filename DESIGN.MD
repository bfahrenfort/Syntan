# Compiler Project Architecture
## Files
### cabal-haskell
Original project structure with several small generic structures that I built the scanner on top of.
### src
* **c**: C code files.
* **haskell**: Haskell code files.

### include
Header files for the entire program.
* **compiler**: Main headers used in program.
* **stubs**: Headers for C prototypes generated by GHC when compiling Haskell modules that export symbols.

### lib
Library binaries with corresponding headers in `include`.
### tmp
Output directory for intermediary object and interface files.
### bin
Output for executables.

## Compilation
1. Compile the Haskell files with `outputdir` set to `tmp` and `stubdir` set to `include/stubs`.
2. compile the C/C++ code and link it to the Haskell objects in tmp as well as any required libraries (currently `stdc++` and `KirbParse`).

## Commands I used
1. `ghc -c -O src/haskell/** -outputdir tmp -stubdir include/stubs -Iinclude -itmp`: Any exported symbols have stubs generated with include directory `include` into `tmp` with stubs placed in `include/stubs`. `tmp` is added to the search path to allow for dependencies.
2. `ghc --make src/c/* src/haskell/* -no-hs-main -outputdir tmp -Llib -Iinclude -o bin/syntan`: uses GHC's ability to heuristically call `gcc` to compile the entire project with include directory `include` without a Haskell main function into `tmp`, then look for libraries in `lib` and link, placing the binary in `bin`
